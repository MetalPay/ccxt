# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.base.exchange import Exchange
import hashlib
import math
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import AuthenticationError
from ccxt.base.errors import RateLimitExceeded


class metalx(Exchange):

    def describe(self):
        return self.deep_extend(super(metalx, self).describe(), {
            'id': 'metalx',
            'name': 'Metalx',
            'countries': ['US', 'EU'],
            'version': 'v1',
            'rateLimit': 400,  # 10k calls per hour
            'has': {
                'fetchTicker': True,
                'fetchCurrencies': True,
                'fetchFundingLimits': True,
                'fetchTradingFees': True,
                'fetchOrderBook': True,
                'fetchTrades': True,
                'fetchOHLCV': True,
                'fetchBalance': True,
                'createOrder': True,
                'cancelOrder': True,
                'fetchOrder': True,
                'fetchOpenOrders': True,
                'fetchOrders': True,
                'fetchMyTrades': True,
                'fetchDepositAddress': True,
                'fetchDeposits': True,
                'fetchWithdrawals': True,
                'fetchTransactions': False,
                'withdraw': True,
            },
            'timeframes': {
                '1m': '1m',
                '5m': '5m',
                '30m': '30m',
                '1h': '1h',
                '1d': '1d',
            },
            'urls': {
                'logo': 'metalx.com',
                'api': 'https://api-staging.metalx.com',
                'www': 'https://www.metalx.com',
                'doc': 'https://developers.metalx.com/api',
            },
            'api': {
                'public': {
                    'get': [
                        'exchange-info',  # fetchMarkets
                        'tickers',  # fetchTicker
                        'assets',  # fetchCurrencies
                        'depth',  # fetchOrderBook
                        'trades',  # fetchTrades
                        'ohlcv',  # fetchOHLCV
                    ],
                },
                'private': {
                    'get': [
                        'account',  # fetchBalance
                        'deposits',  # fetchDeposits
                        'withdrawals',  # fetchWithdrawals
                        'orders',  # fetchOpenOrders, fetchAllOrders
                        'orders/{orderId}',  # getOrder,
                        'trades/me',  # fetchMyTrades
                        'address/deposit',  # fetchDepositAddress
                    ],
                    'post': [
                        'orders/create',  # createOrder
                        'withdraw',  # withdraw
                    ],
                    'put': [
                        'orders/cancel',  # cancelOrder
                    ],
                },
            },
            'exceptions': {
                'two_factor_required': AuthenticationError,  # 402 When sending money over 2fa limit
                'param_required': ExchangeError,  # 400 Missing parameter
                'validation_error': ExchangeError,  # 400 Unable to validate POST/PUT
                'invalid_request': ExchangeError,  # 400 Invalid request
                'authentication_error': AuthenticationError,  # 401 Invalid auth(generic)
                'invalid_token': AuthenticationError,  # 401 Invalid Oauth token
                'revoked_token': AuthenticationError,  # 401 Revoked Oauth token
                'expired_token': AuthenticationError,  # 401 Expired Oauth token
                'invalid_scope': AuthenticationError,  # 403 User hasnâ€™t authenticated necessary scope
                'not_found': ExchangeError,  # 404 Resource not found
                'rate_limit_exceeded': RateLimitExceeded,  # 429 Rate limit exceeded
                'internal_server_error': ExchangeError,  # 500 Internal server error
            },
            'options': None,
        })

    def fetch_markets(self, params={}):
        response = self.publicGetExchangeInfo(params)
        # {
        #   "timezone": "UTC",
        #   "serverTime": 1589483200696,
        #   "symbols": [
        #       {
        #           "symbol": "MTLBTC",
        #           "status": "running",
        #           "baseAsset": "MTL",
        #           "baseAssetPrecision": 8,
        #           "quoteAsset": "BTC",
        #           "quotePrecision": 8,
        #           "baseCommissionPrecision": 8,
        #           "quoteCommissionPrecision": 8,
        #           "orderTypes": [
        #               "LIMIT",
        #               "LIMIT_MAKER",
        #               "MARKET",
        #               "STOP_LOSS",
        #               "STOP_LOSS_LIMIT",
        #               "TAKE_PROFIT",
        #               "TAKE_PROFIT_LIMIT"
        #           ],
        #           "isSpotTradingAllowed": True,
        #           "isMarginTradingAllowed": False
        #         }
        #       ],
        #   }
        result = []
        for i in range(0, len(response.symbols)):
            market = response[i]
            id = self.safe_string(market, 'symbol')
            baseId = self.safe_string(market, 'baseAsset')
            quoteId = self.safe_string(market, 'quoteAsset')
            base = self.safe_currency_code(baseId)
            quote = self.safe_currency_code(quoteId)
            symbol = base + '/' + quote
            precision = {
                'amount': self.safe_integer(market, 'quotePrecision'),
                'price': self.safe_integer(market, 'quoteCommissionPrecision'),
            }
            status = self.safe_string(market, 'status')
            active = (status == 'running')
            result.append({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'baseId': baseId,
                'quoteId': quoteId,
                'info': market,
                'active': active,
                'precision': precision,
                'limits': {
                    'amount': {'min': None, 'max': None},
                    'price': {'min': None, 'max': None},
                    'cost': {'min': None, 'max': None},
                },
            })
        return result

    def fetch_currencies(self, params={}):
        response = self.publicGetAssets(params)
        # [
        #   {
        #       "id": "BTC",
        #       "code": "BTC",
        #       "name": "Bitcoin",
        #       "active": True,
        #       "fee": 0.0003,
        #       "precision": 8
        #   },
        # ]
        result = {}
        for i in range(0, len(response)):
            currency = response[i]
            id = self.safe_string(currency, 'id')
            code = self.safe_string(currency, 'code')
            name = self.safe_string(currency, 'name')
            active = self.safe_value(currency, 'active')
            fee = self.safe_float(currency, 'fee')
            precision = self.safe_integer(currency, 'precision')
            result[code] = {
                'id': id,
                'code': code,
                'info': currency,
                'name': name,
                'active': active,
                'fee': fee,
                'precision': precision,
                'limits': {
                    'amount': {
                        'min': math.pow(10, -precision),
                        'max': None,
                    },
                    'price': {
                        'min': math.pow(10, -precision),
                        'max': None,
                    },
                    'cost': {
                        'min': None,
                        'max': None,
                    },
                    'withdraw': {
                        'min': None,
                        'max': None,
                    },
                },
            }
        return result

    def fetch_order_book(self, symbol, limit=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
        }
        if limit is not None:
            request['depth'] = limit
        response = self.publicGetDepth(self.extend(request, params))
        # {
        #     "serverTime": 1589494284189,
        #     "dateTime": "2020-05-14T22:11:24.189Z",
        #     "bids": [
        #      {
        #         "quantity": 227,
        #         "price": 0.00002931
        #      },
        #      {
        #         "quantity": 264,
        #         "price": 0.00002928
        #      }
        #    ],
        #     "asks": [
        #      {
        #        "quantity": 802,
        #        "price": 0.00002943
        #      },
        #      {
        #        "quantity": 2905,
        #        "price": 0.00002944
        #      },
        # }
        response.bids = response.bids.map((bid) => Object.values(bid))
        response.asks = response.asks.map((ask) => Object.values(ask))
        timestamp = self.safe_integer(response, 'serverTime')
        result = self.parse_order_book(response, timestamp)
        result['nonce'] = timestamp
        return result

    def fetch_trades(self, symbol, since=None, limit=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
        }
        if limit is not None:
            request['limit'] = limit
        response = self.publicGetTrades(self.extend(request, params))
        return self.parse_trades(response, market, since, limit)

    def parse_trade(self, trade, market=None):
        # PUBLIC fetchtrades
        # [
        #   {
        #       "timestamp": 1589493840302,
        #       "datetime": "2020-05-14T22:04:00.302Z",
        #       "symbol": "MTLBTC",
        #       "price": "0.00002947",
        #       "amount": "1.28985624",
        #       "cost": "0.0000380120633928"
        #   },
        # ]
        # PRIVATE fetchTrades
        #     [
        # {
        #     "id": "2419962",
        #     "timestamp": 1589292571101,
        #     "datetime": "2020-05-12T14:09:31.101Z",
        #     "symbol": "MTL/BTC",
        #     "order": 1975994,
        #     "type": "Market",
        #     "side": "sell",
        #     "takerOrMaker": "taker",
        #     "price": "0.0016",
        #     "amount": "1",
        #     "cost": "0.0016",
        #     "fee": {
        #         "cost": "8e-7",
        #         "currency": "BTC"
        #     }
        # },
        timestamp = self.safe_integer(trade, 'timestamp')
        price = self.safe_float(trade, 'price')
        amount = self.safe_float(trade, 'amount')
        cost = self.safe_float(trade, 'cost')
        symbol = None
        if market is None:
            marketId = self.safe_string(trade, 'symbol')
            market = self.safe_value(self.markets_by_id, marketId)
        if market is not None:
            symbol = market['symbol']
        # Revisit later when doing personal trades
        id = self.safe_string(trade, 'id')
        order = self.safe_string(trade, 'order')
        type = self.safe_string(trade, 'type')
        takerOrMaker = self.safe_string(trade, 'takerOrMaker')
        side = self.safe_string(trade, 'side')
        fee = self.safe_value(trade, 'fee')
        return {
            'info': trade,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'symbol': symbol,
            'id': id,
            'order': order,
            'type': type,
            'takerOrMaker': takerOrMaker,
            'side': side,
            'price': price,
            'amount': amount,
            'cost': cost,
            'fee': fee,
        }

    def fetch_ohlcv(self, symbol, timeframe='1m', since=None, limit=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
            'interval': self.timeframes[timeframe],
        }
        if since is not None:
            request['since'] = since
        else:
            request['since'] = Date()
        if limit is not None:
            request['limit'] = limit
        response = self.publicGetOhlcv(self.extend(request, params))
        return self.parse_ohlcvs(response, market, timeframe, since, limit)

    def parse_ohlcv(self, ohlcv, market=None, timeframe='1m', since=None, limit=None):
        # [
        #   1589328000000,
        #   0.0015,
        #   0.0016,
        #   0.00003103,
        #   0.00003143,
        #   418.09725549
        # ],
        return [
            int(ohlcv[0]),
            float(ohlcv[1]),
            float(ohlcv[2]),
            float(ohlcv[3]),
            float(ohlcv[4]),
            float(ohlcv[5]),
        ]

    def fetch_balance(self, params={}):
        self.load_markets()
        response = self.privateGetAccount(params)
        # {
        #   "accountType": "spot",
        #   "balances": [
        #       {
        #           "asset": "BTC",
        #           "free": "1.8757842855900473",
        #           "locked": "0"
        #       },
        #       {
        #           "asset": "LTC",
        #           "free": "0",
        #           "locked": "0"
        #       },
        # }
        result = {'info': response}
        balances = self.safe_value(response, 'balances')
        for i in range(0, len(balances)):
            balance = balances[i]
            currencyId = self.safe_string(balance, 'asset')
            code = self.safe_currency_code(currencyId)
            account = self.account()
            account['free'] = self.safe_float(balance, 'free')
            account['locked'] = self.safe_float(balance, 'locked')
            account['total'] = self.sum(account['free'], account['locked'])
            result[code] = account
        return self.parse_balance(result)

    def create_order(self, symbol, type, side, amount, price=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
            'side': side,
            'type': type,
            'quantity': amount,
        }
        if type == 'limit':
            request['limitPrice'] = self.price_to_precision(symbol, price)
        response = self.privatePostOrder(self.extend(request, params))
        return self.parse_order(response)

    def cancel_order(self, id, symbol=None, params={}):
        self.load_markets()
        request = {
            'orderId': id,
        }
        response = self.privatePutOrdersCancel(self.extend(request, params))
        #
        #     -- LIMIT ORDERS --
        #     {
        #       "id": 2075345,
        #       "datetime": "2020-05-15T15:58:08.890Z",
        #       "timestamp": 1589558288890,
        #       "status": "Canceled",
        #       "symbol": "MTLBTC",
        #       "type": "limit",
        #       "side": "sell",
        #       "price": "10",  # will only be present for limit orders
        #       "amount": "1",
        #       "filled": "0",
        #       "remaining": "1",
        #       "cost": "0"
        # }
        # -- MARKET ORDERS --
        # {
        #       "id": 1495144,
        #       "datetime": "2020-04-21T16:11:29.504Z",
        #       "timestamp": 1587485489504,
        #       "status": "FullyExecuted",
        #       "symbol": "MTL/BTC",
        #       "type": "market",
        #       "side": "buy",
        #       "price": "0",
        #       "amount": "100",
        #       "filled": "100",
        #       "remaining": "0",
        #       "cost": "0"
        # }
        #
        #
        return self.parse_order(response)

    def parse_order(self, order, market=None):
        status = self.parse_order_status(self.safe_string(order, 'status'))
        timestamp = self.parse8601(self.safe_string(order, 'timestamp'))
        symbol = None
        marketId = self.safe_string(order, 'symbol')
        if marketId in self.markets_by_id:
            market = self.markets_by_id[marketId]
        if market is not None:
            symbol = market['symbol']
        price = self.safe_float(order, 'price')
        remaining = self.safe_float(order, 'remaining')
        amount = self.safe_float(order, 'origQty')
        filled = self.safe_float(order, 'executedQty')
        cost = self.safe_string(order, 'cost')
        id = self.safe_string(order, 'id')
        type = self.safe_string(order, 'type')
        if type is not None:
            type = type.lower()
            if type == 'market':
                if price == 0.0:
                    if (cost is not None) and (filled is not None):
                        if (cost > 0) and (filled > 0):
                            price = cost / filled
        side = self.safe_string_lower(order, 'side')
        clientOrderId = id
        # TODO: Need to get average price
        average = self.safe_float(order, 'avgPrice')
        return {
            'info': order,
            'id': id,
            'clientOrderId': clientOrderId,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'lastTradeTimestamp': None,
            'symbol': symbol,
            'type': type,
            'side': side,
            'price': price,
            'amount': amount,
            'cost': cost,
            'average': average,
            'filled': filled,
            'remaining': remaining,
            'status': status,
            'fee': None,
            'trades': None,
        }

    def fetch_order(self, id, symbol=None, params={}):
        self.load_markets()
        request = {
            'orderId': id,
        }
        response = self.privateGetOrder(self.extend(request, params))
        #
        #
        #   {
        #       "id": 1495144,
        #       "datetime": "2020-04-21T16:11:29.504Z",
        #       "timestamp": 1587485489504,
        #       "status": "FullyExecuted",
        #       "symbol": "MTL/BTC",
        #       "type": "market",
        #       "side": "buy",
        #       "price": "0",
        #       "amount": "100",
        #       "filled": "100",
        #       "remaining": "0",
        #       "cost": "0"
        # }
        #
        return self.parse_order(response)

    def fetch_open_orders(self, symbol=None, since=None, limit=None, params={}):
        request = {
            'status': 'open',
        }
        response = self.privateGetOrders(self.extend(request, params))
        return self.parse_orders(response)

    def fetch_orders(self, symbol=None, since=None, limit=None, params={}):
        request = {
            'status': 'all',
        }
        response = self.privateGetOrders(self.extend(request, params))
        return self.parse_orders(response)

    def fetch_my_trades(self, symbol=None, since=None, limit=None, params={}):
        request = {}
        market = None
        if symbol is not None:
            self.load_markets()
            market = self.market(symbol)
            request['symbol'] = market['id']
        if since is not None:
            request['startTime'] = since
        if limit is not None:
            request['limit'] = limit  # Max is 200
        response = self.privateGetTradesMe(self.extend(request, params))
        return self.parse_trades(response, market, since, limit)

    def fetch_deposit_address(self, code, params={}):
        self.load_markets()
        currency = self.currency(code)
        request = {
            'currency': currency['id'],
        }
        response = self.privateGetAddressDeposit(self.extend(request, params))
        # {
        #   "currency": "XRP",
        #   "address": "r3e95RwVsLH7yCbnMfyh7SA8FdwUJCB4S2?memo=210833370",
        #   "tag": "210833370"  # only for select currencies
        # }
        address = self.safe_string(response, 'address')
        tag = self.safe_string(response, 'tag')
        self.check_address(address)
        return {
            'currency': code,
            'address': self.check_address(address),
            'tag': tag,
            'info': response,
        }

    def fetch_deposits(self, code=None, since=None, limit=None, params={}):
        #
        #  [
        #    {
        #      "id": 9,
        #      "txid": "7a91c5b321ed7f75d985c6374561e0a8de6f8ef1fa9093437e81805b0759afa8",
        #      "timestamp": 1585236999069,
        #      "datetime": "2020-03-26T15:36:39.069Z",
        #      "addressTo": "bnb1j5jqey3xvs2w43x8540sd8nzykg4pyl4cvkl6x",
        #      "address": "bnb1j5jqey3xvs2w43x8540sd8nzykg4pyl4cvkl6x",
        #      "type": "deposit",
        #      "amount": 0.1,
        #      "currency": "BNB",
        #      "status": "FullyProcessed"
        #    },
        request = {}
        self.load_markets()
        currency = None
        if code is not None:
            currency = self.currency(code)
            request['currency'] = currency
        # No limit or since filter
        response = self.privateGetDeposits(self.extend(request, params))
        return self.parse_transactions(response, currency, since, limit)

    def fetch_withdrawals(self, code=None, since=None, limit=None, params={}):
        self.load_markets()
        request = {}
        currency = None
        if code is not None:
            currency = self.currency(code)
            request['currency'] = currency
        # No limit or since filter
        response = self.privateGetWithdrawals(self.extend(request, params))
        return self.parse_transactions(response, currency, since, limit)

    def parse_transaction(self, transaction, currency=None):
        #
        #
        # -- DEPOSIT --
        # {
        # "id": 9,
        # "txid": "7a91c5b321ed7f75d985c6374561e0a8de6f8ef1fa9093437e81805b0759afa8",
        # "timestamp": 1585236999069,
        # "datetime": "2020-03-26T15:36:39.069Z",
        # "addressTo": "bnb1j5jqey3xvs2w43x8540sd8nzykg4pyl4cvkl6x",
        # "address": "bnb1j5jqey3xvs2w43x8540sd8nzykg4pyl4cvkl6x",
        # "tag": "433519032",  # only for some currencies
        # "type": "deposit",
        # "amount": 0.1,
        # "currency": "BNB",
        # "status": "FullyProcessed"
        # },
        #
        # -- WITHDRAW --
        # {
        # "id": 35,
        # "txid": null,
        # "timestamp": 1588588996163,
        # "datetime": "2020-05-04T10:43:16.163Z",
        # "addressTo": "1Lku3CjJueSvuaexy3WQJAR9GL2q4rHV46",
        # "address": "1Lku3CjJueSvuaexy3WQJAR9GL2q4rHV46",
        # "type": "withdraw",
        # "amount": 1,
        # "currency": "BTC",
        # "status": "Pending2Fa",
        # "updated": 1588588996163,
        # "fee": {
        #       "currency": "BTC",
        #       "cost": 0.0001
        # }
        # },
        #
        #
        id = self.safe_string(transaction, 'id')
        address = self.safe_string(transaction, 'address')
        tag = self.safe_string(transaction, 'tag')
        txid = self.safe_value(transaction, 'txid')
        currencyId = self.safe_string(transaction, 'currency')
        code = self.safe_currency_code(currencyId)
        timestamp = self.parse8601(self.safe_value(transaction, 'timestamp'))
        status = self.safe_string(transaction, 'status')
        type = self.safe_string(transaction, 'type')
        amount = self.safe_float(transaction, 'amount')
        fee = self.safe_value(transaction, 'fee')
        return {
            'info': transaction,
            'id': id,
            'txid': txid,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'address': address,
            'tag': tag,
            'type': type,
            'amount': amount,
            'currency': code,
            'status': status,
            'updated': None,
            'fee': fee,
        }

    def withdraw(self, code, amount, address, tag=None, params={}):
        self.check_address(address)
        self.load_markets()
        currency = self.currency(code)
        request = {
            'currency': currency['id'],
            'address': address,
            'amount': float(amount),
        }
        # if tag is not None:
        #     request['addressTag'] = tag
        # }
        response = self.privatePostWithdraw(self.extend(request, params))
        return {
            'info': response,
            'id': self.safe_string(response, 'id'),
        }

    def fetch_ticker(self, symbol, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],  # i.e. MTLBTC
        }
        response = self.publicGetTickers(self.extend(request, params))
        return self.parse_ticker(response, market)

    def fetch_tickers(self, symbols=None, params={}):
        self.load_markets()
        response = self.publicGetTickers(params)
        return self.parse_tickers(response, symbols)

    def parse_tickers(self, rawTickers, symbols=None):
        tickers = []
        for i in range(0, len(rawTickers)):
            tickers.append(self.parse_ticker(rawTickers[i]))
        return self.filter_by_array(tickers, 'symbol', symbols)

    def parse_ticker(self, ticker, market=None):
        # {
        #   "symbol": "MTLBTC",
        #   "bidPrice": "0.00002931",
        #   "askPrice": "0.00002946",
        #   "lastPrice": "0.00002946",
        #   "openPrice": "0.00003047",
        #   "highPrice": "0.00003149",
        #   "lowPrice": "0.00002842",
        #   "volume": "2085.6791445"
        # },
        symbol = None
        marketId = self.safe_string(ticker, 'symbol')
        if marketId in self.markets_by_id:
            market = self.markets_by_id[marketId]
        if market is not None:
            symbol = market['symbol']
        last = self.safe_float(ticker, 'lastPrice')
        return {
            'symbol': symbol,
            'timestamp': None,
            'datetime': None,
            'high': self.safe_float(ticker, 'highPrice'),
            'low': self.safe_float(ticker, 'lowPrice'),
            'bid': self.safe_float(ticker, 'bidPrice'),
            'bidVolume': None,
            'ask': self.safe_float(ticker, 'askPrice'),
            'askVolume': None,
            'vwap': None,
            'open': self.safe_float(ticker, 'openPrice'),
            'close': last,
            'last': last,
            'previousClose': None,  # previous day close
            'change': None,
            'percentage': None,
            'average': None,
            'baseVolume': self.safe_float(ticker, 'volume'),
            'quoteVolume': None,
            'info': ticker,
        }

    def nonce(self):
        return self.milliseconds()

    def sign(self, path, api='public', method='GET', params={}, headers=None, body=None):
        fullPath = '/' + self.version + '/' + self.implode_params(path, params)
        query = self.omit(params, self.extract_params(path))
        if method == 'GET':
            if query:
                fullPath += '?' + self.urlencode(query)
        url = self.urls['api'] + fullPath
        if api == 'private':
            self.check_required_credentials()
            if method != 'GET':
                if query:
                    body = self.json(query)
            nonce = self.nonce()
            apiKey = self.apiKey
            user = self.uid
            auth = nonce + apiKey + user
            signature = self.hmac(self.encode(auth), self.encode(self.secret), hashlib.sha256)
            headers = {
                'MX-API-KEY': apiKey,
                'MX-API-USER': user,
                'MX-SIGNATURE': signature,
                'MX-NONCE': nonce,
            }
        return {'url': url, 'method': method, 'body': body, 'headers': headers}
