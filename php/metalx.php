<?php

namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import

class metalx extends Exchange {

    public function describe() {
        return $this->deep_extend(parent::describe (), array(
            'id' => 'metalx',
            'name' => 'Metalx',
            'countries' => ['US', 'EU'],
            'version' => 'v1',
            'rateLimit' => 400,  // 10k calls per hour
            'has' => array(
                'fetchTicker' => true,
                'fetchCurrencies' => true,
                'fetchFundingLimits' => true,
                'fetchTradingFees' => true,
                'fetchOrderBook' => true,
                'fetchTrades' => true,
                'fetchOHLCV' => true,
                'fetchBalance' => true,
                'createOrder' => true,
                'cancelOrder' => true,
                'fetchOrder' => true,
                'fetchOpenOrders' => true,
                'fetchOrders' => true,
                'fetchMyTrades' => true,
                'fetchDepositAddress' => true,
                'fetchDeposits' => true,
                'fetchWithdrawals' => true,
                'fetchTransactions' => false,
                'withdraw' => true,
            ),
            'timeframes' => array(
                '1m' => '1m',
                '5m' => '5m',
                '30m' => '30m',
                '1h' => '1h',
                '1d' => '1d',
            ),
            'urls' => array(
                'logo' => 'metalx.com',
                'api' => 'https://api-staging.metalx.com',
                'www' => 'https://www.metalx.com',
                'doc' => 'https://developers.metalx.com/api',
            ),
            'api' => array(
                'public' => array(
                    'get' => array(
                        'exchange-info', // fetchMarkets
                        'tickers', // fetchTicker
                        'assets', // fetchCurrencies
                        'depth', // fetchOrderBook
                        'trades', // fetchTrades
                        'ohlcv', // fetchOHLCV
                    ),
                ),
                'private' => array(
                    'get' => array(
                        'account', // fetchBalance
                        'deposits', // fetchDeposits
                        'withdrawals', // fetchWithdrawals
                        'orders', // fetchOpenOrders, fetchAllOrders
                        'orders/{orderId}', // getOrder,
                        'trades/me', // fetchMyTrades
                        'address/deposit', // fetchDepositAddress
                    ),
                    'post' => array(
                        'orders/create', // createOrder
                        'withdraw', // withdraw
                    ),
                    'put' => array(
                        'orders/cancel', // cancelOrder
                    ),
                ),
            ),
            'exceptions' => array(
                'two_factor_required' => '\\ccxt\\AuthenticationError', // 402 When sending money over 2fa limit
                'param_required' => '\\ccxt\\ExchangeError', // 400 Missing parameter
                'validation_error' => '\\ccxt\\ExchangeError', // 400 Unable to validate POST/PUT
                'invalid_request' => '\\ccxt\\ExchangeError', // 400 Invalid request
                'authentication_error' => '\\ccxt\\AuthenticationError', // 401 Invalid auth (generic)
                'invalid_token' => '\\ccxt\\AuthenticationError', // 401 Invalid Oauth token
                'revoked_token' => '\\ccxt\\AuthenticationError', // 401 Revoked Oauth token
                'expired_token' => '\\ccxt\\AuthenticationError', // 401 Expired Oauth token
                'invalid_scope' => '\\ccxt\\AuthenticationError', // 403 User hasnâ€™t authenticated necessary scope
                'not_found' => '\\ccxt\\ExchangeError', // 404 Resource not found
                'rate_limit_exceeded' => '\\ccxt\\RateLimitExceeded', // 429 Rate limit exceeded
                'internal_server_error' => '\\ccxt\\ExchangeError', // 500 Internal server error
            ),
            'options' => null,
        ));
    }

    public function fetch_markets($params = array ()) {
        $response = $this->publicGetExchangeInfo ($params);
        // {
        //   "timezone" => "UTC",
        //   "serverTime" => 1589483200696,
        //   "symbols" => array(
        //       {
        //           "$symbol" => "MTLBTC",
        //           "$status" => "running",
        //           "baseAsset" => "MTL",
        //           "baseAssetPrecision" => 8,
        //           "quoteAsset" => "BTC",
        //           "quotePrecision" => 8,
        //           "baseCommissionPrecision" => 8,
        //           "quoteCommissionPrecision" => 8,
        //           "orderTypes" => array(
        //               "LIMIT",
        //               "LIMIT_MAKER",
        //               "MARKET",
        //               "STOP_LOSS",
        //               "STOP_LOSS_LIMIT",
        //               "TAKE_PROFIT",
        //               "TAKE_PROFIT_LIMIT"
        //           ),
        //           "isSpotTradingAllowed" => true,
        //           "isMarginTradingAllowed" => false
        //         }
        //       ),
        //   }
        $result = array();
        for ($i = 0; $i < count($response->symbols); $i++) {
            $market = $response[$i];
            $id = $this->safe_string($market, 'symbol');
            $baseId = $this->safe_string($market, 'baseAsset');
            $quoteId = $this->safe_string($market, 'quoteAsset');
            $base = $this->safe_currency_code($baseId);
            $quote = $this->safe_currency_code($quoteId);
            $symbol = $base . '/' . $quote;
            $precision = array(
                'amount' => $this->safe_integer($market, 'quotePrecision'),
                'price' => $this->safe_integer($market, 'quoteCommissionPrecision'),
            );
            $status = $this->safe_string($market, 'status');
            $active = ($status === 'running');
            $result[] = array(
                'id' => $id,
                'symbol' => $symbol,
                'base' => $base,
                'quote' => $quote,
                'baseId' => $baseId,
                'quoteId' => $quoteId,
                'info' => $market,
                'active' => $active,
                'precision' => $precision,
                'limits' => array(
                    'amount' => array( 'min' => null, 'max' => null ),
                    'price' => array( 'min' => null, 'max' => null ),
                    'cost' => array( 'min' => null, 'max' => null ),
                ),
            );
        }
        return $result;
    }

    public function fetch_currencies($params = array ()) {
        $response = $this->publicGetAssets ($params);
        // array(
        //   array(
        //       "$id" => "BTC",
        //       "$code" => "BTC",
        //       "$name" => "Bitcoin",
        //       "$active" => true,
        //       "$fee" => 0.0003,
        //       "$precision" => 8
        //   ),
        // )
        $result = array();
        for ($i = 0; $i < count($response); $i++) {
            $currency = $response[$i];
            $id = $this->safe_string($currency, 'id');
            $code = $this->safe_string($currency, 'code');
            $name = $this->safe_string($currency, 'name');
            $active = $this->safe_value($currency, 'active');
            $fee = $this->safe_float($currency, 'fee');
            $precision = $this->safe_integer($currency, 'precision');
            $result[$code] = array(
                'id' => $id,
                'code' => $code,
                'info' => $currency,
                'name' => $name,
                'active' => $active,
                'fee' => $fee,
                'precision' => $precision,
                'limits' => array(
                    'amount' => array(
                        'min' => pow(10, -$precision),
                        'max' => null,
                    ),
                    'price' => array(
                        'min' => pow(10, -$precision),
                        'max' => null,
                    ),
                    'cost' => array(
                        'min' => null,
                        'max' => null,
                    ),
                    'withdraw' => array(
                        'min' => null,
                        'max' => null,
                    ),
                ),
            );
        }
        return $result;
    }

    public function fetch_order_book($symbol, $limit = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        if ($limit !== null) {
            $request['depth'] = $limit;
        }
        $response = $this->publicGetDepth (array_merge($request, $params));
        // {
        //     "serverTime" => 1589494284189,
        //     "dateTime" => "2020-05-14T22:11:24.189Z",
        //     "bids" => array(
        //      array(
        //         "quantity" => 227,
        //         "price" => 0.00002931
        //      ),
        //      {
        //         "quantity" => 264,
        //         "price" => 0.00002928
        //      }
        //    ),
        //     "asks" => [
        //      array(
        //        "quantity" => 802,
        //        "price" => 0.00002943
        //      ),
        //      array(
        //        "quantity" => 2905,
        //        "price" => 0.00002944
        //      ),
        // }
        $response->bids = $response->bids.map ((bid) => Object.values (bid));
        $response->asks = $response->asks.map ((ask) => Object.values (ask));
        $timestamp = $this->safe_integer($response, 'serverTime');
        $result = $this->parse_order_book($response, $timestamp);
        $result['nonce'] = $timestamp;
        return $result;
    }

    public function fetch_trades($symbol, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $response = $this->publicGetTrades (array_merge($request, $params));
        return $this->parse_trades($response, $market, $since, $limit);
    }

    public function parse_trade($trade, $market = null) {
        // PUBLIC fetchtrades
        // array(
        //   array(
        //       "$timestamp" => 1589493840302,
        //       "datetime" => "2020-05-14T22:04:00.302Z",
        //       "$symbol" => "MTLBTC",
        //       "$price" => "0.00002947",
        //       "$amount" => "1.28985624",
        //       "$cost" => "0.0000380120633928"
        //   ),
        // )
        // PRIVATE fetchTrades
        //     [
        // {
        //     "$id" => "2419962",
        //     "$timestamp" => 1589292571101,
        //     "datetime" => "2020-05-12T14:09:31.101Z",
        //     "$symbol" => "MTL/BTC",
        //     "$order" => 1975994,
        //     "$type" => "Market",
        //     "$side" => "sell",
        //     "$takerOrMaker" => "taker",
        //     "$price" => "0.0016",
        //     "$amount" => "1",
        //     "$cost" => "0.0016",
        //     "$fee" => array(
        //         "$cost" => "8e-7",
        //         "currency" => "BTC"
        //     }
        // ),
        $timestamp = $this->safe_integer($trade, 'timestamp');
        $price = $this->safe_float($trade, 'price');
        $amount = $this->safe_float($trade, 'amount');
        $cost = $this->safe_float($trade, 'cost');
        $symbol = null;
        if ($market === null) {
            $marketId = $this->safe_string($trade, 'symbol');
            $market = $this->safe_value($this->markets_by_id, $marketId);
        }
        if ($market !== null) {
            $symbol = $market['symbol'];
        }
        // Revisit later when doing personal trades
        $id = $this->safe_string($trade, 'id');
        $order = $this->safe_string($trade, 'order');
        $type = $this->safe_string($trade, 'type');
        $takerOrMaker = $this->safe_string($trade, 'takerOrMaker');
        $side = $this->safe_string($trade, 'side');
        $fee = $this->safe_value($trade, 'fee');
        return array(
            'info' => $trade,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $symbol,
            'id' => $id,
            'order' => $order,
            'type' => $type,
            'takerOrMaker' => $takerOrMaker,
            'side' => $side,
            'price' => $price,
            'amount' => $amount,
            'cost' => $cost,
            'fee' => $fee,
        );
    }

    public function fetch_ohlcv($symbol, $timeframe = '1m', $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
            'interval' => $this->timeframes[$timeframe],
        );
        if ($since !== null) {
            $request['since'] = $since;
        } else {
            $request['since'] = new Date ();
        }
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $response = $this->publicGetOhlcv (array_merge($request, $params));
        return $this->parse_ohlcvs($response, $market, $timeframe, $since, $limit);
    }

    public function parse_ohlcv($ohlcv, $market = null, $timeframe = '1m', $since = null, $limit = null) {
        // array(
        //   1589328000000,
        //   0.0015,
        //   0.0016,
        //   0.00003103,
        //   0.00003143,
        //   418.09725549
        // ),
        return [
            intval ($ohlcv[0]),
            floatval ($ohlcv[1]),
            floatval ($ohlcv[2]),
            floatval ($ohlcv[3]),
            floatval ($ohlcv[4]),
            floatval ($ohlcv[5]),
        ];
    }

    public function fetch_balance($params = array ()) {
        $this->load_markets();
        $response = $this->privateGetAccount ($params);
        // {
        //   "accountType" => "spot",
        //   "$balances" => [
        //       array(
        //           "asset" => "BTC",
        //           "free" => "1.8757842855900473",
        //           "locked" => "0"
        //       ),
        //       array(
        //           "asset" => "LTC",
        //           "free" => "0",
        //           "locked" => "0"
        //       ),
        // }
        $result = array( 'info' => $response );
        $balances = $this->safe_value($response, 'balances');
        for ($i = 0; $i < count($balances); $i++) {
            $balance = $balances[$i];
            $currencyId = $this->safe_string($balance, 'asset');
            $code = $this->safe_currency_code($currencyId);
            $account = $this->account();
            $account['free'] = $this->safe_float($balance, 'free');
            $account['locked'] = $this->safe_float($balance, 'locked');
            $account['total'] = $this->sum($account['free'], $account['locked']);
            $result[$code] = $account;
        }
        return $this->parse_balance($result);
    }

    public function create_order($symbol, $type, $side, $amount, $price = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'],
            'side' => $side,
            'type' => $type,
            'quantity' => $amount,
        );
        if ($type === 'limit') {
            $request['limitPrice'] = $this->price_to_precision($symbol, $price);
        }
        $response = $this->privatePostOrder (array_merge($request, $params));
        return $this->parse_order($response);
    }

    public function cancel_order($id, $symbol = null, $params = array ()) {
        $this->load_markets();
        $request = array(
            'orderId' => $id,
        );
        $response = $this->privatePutOrdersCancel (array_merge($request, $params));
        //
        //     -- LIMIT ORDERS --
        //     {
        //       "$id" => 2075345,
        //       "datetime" => "2020-05-15T15:58:08.890Z",
        //       "timestamp" => 1589558288890,
        //       "status" => "Canceled",
        //       "$symbol" => "MTLBTC",
        //       "type" => "limit",
        //       "side" => "sell",
        //       "price" => "10", // will only be present for limit orders
        //       "amount" => "1",
        //       "filled" => "0",
        //       "remaining" => "1",
        //       "cost" => "0"
        // }
        // -- MARKET ORDERS --
        // {
        //       "$id" => 1495144,
        //       "datetime" => "2020-04-21T16:11:29.504Z",
        //       "timestamp" => 1587485489504,
        //       "status" => "FullyExecuted",
        //       "$symbol" => "MTL/BTC",
        //       "type" => "market",
        //       "side" => "buy",
        //       "price" => "0",
        //       "amount" => "100",
        //       "filled" => "100",
        //       "remaining" => "0",
        //       "cost" => "0"
        // }
        //
        //
        return $this->parse_order($response);
    }

    public function parse_order($order, $market = null) {
        $status = $this->parse_order_status($this->safe_string($order, 'status'));
        $timestamp = $this->parse8601($this->safe_string($order, 'timestamp'));
        $symbol = null;
        $marketId = $this->safe_string($order, 'symbol');
        if (is_array($this->markets_by_id) && array_key_exists($marketId, $this->markets_by_id)) {
            $market = $this->markets_by_id[$marketId];
        }
        if ($market !== null) {
            $symbol = $market['symbol'];
        }
        $price = $this->safe_float($order, 'price');
        $remaining = $this->safe_float($order, 'remaining');
        $amount = $this->safe_float($order, 'origQty');
        $filled = $this->safe_float($order, 'executedQty');
        $cost = $this->safe_string($order, 'cost');
        $id = $this->safe_string($order, 'id');
        $type = $this->safe_string($order, 'type');
        if ($type !== null) {
            $type = strtolower($type);
            if ($type === 'market') {
                if ($price === 0.0) {
                    if (($cost !== null) && ($filled !== null)) {
                        if (($cost > 0) && ($filled > 0)) {
                            $price = $cost / $filled;
                        }
                    }
                }
            }
        }
        $side = $this->safe_string_lower($order, 'side');
        $clientOrderId = $id;
        // TODO => Need to get $average $price
        $average = $this->safe_float($order, 'avgPrice');
        return array(
            'info' => $order,
            'id' => $id,
            'clientOrderId' => $clientOrderId,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastTradeTimestamp' => null,
            'symbol' => $symbol,
            'type' => $type,
            'side' => $side,
            'price' => $price,
            'amount' => $amount,
            'cost' => $cost,
            'average' => $average,
            'filled' => $filled,
            'remaining' => $remaining,
            'status' => $status,
            'fee' => null,
            'trades' => null,
        );
    }

    public function fetch_order($id, $symbol = null, $params = array ()) {
        $this->load_markets();
        $request = array(
            'orderId' => $id,
        );
        $response = $this->privateGetOrder (array_merge($request, $params));
        //
        //
        //   {
        //       "$id" => 1495144,
        //       "datetime" => "2020-04-21T16:11:29.504Z",
        //       "timestamp" => 1587485489504,
        //       "status" => "FullyExecuted",
        //       "$symbol" => "MTL/BTC",
        //       "type" => "market",
        //       "side" => "buy",
        //       "price" => "0",
        //       "amount" => "100",
        //       "filled" => "100",
        //       "remaining" => "0",
        //       "cost" => "0"
        // }
        //
        return $this->parse_order($response);
    }

    public function fetch_open_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        $request = array(
            'status' => 'open',
        );
        $response = $this->privateGetOrders (array_merge($request, $params));
        return $this->parse_orders($response);
    }

    public function fetch_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        $request = array(
            'status' => 'all',
        );
        $response = $this->privateGetOrders (array_merge($request, $params));
        return $this->parse_orders($response);
    }

    public function fetch_my_trades($symbol = null, $since = null, $limit = null, $params = array ()) {
        $request = array();
        $market = null;
        if ($symbol !== null) {
            $this->load_markets();
            $market = $this->market($symbol);
            $request['symbol'] = $market['id'];
        }
        if ($since !== null) {
            $request['startTime'] = $since;
        }
        if ($limit !== null) {
            $request['limit'] = $limit; // Max is 200
        }
        $response = $this->privateGetTradesMe (array_merge($request, $params));
        return $this->parse_trades($response, $market, $since, $limit);
    }

    public function fetch_deposit_address($code, $params = array ()) {
        $this->load_markets();
        $currency = $this->currency($code);
        $request = array(
            'currency' => $currency['id'],
        );
        $response = $this->privateGetAddressDeposit (array_merge($request, $params));
        // {
        //   "$currency" => "XRP",
        //   "$address" => "r3e95RwVsLH7yCbnMfyh7SA8FdwUJCB4S2?memo=210833370",
        //   "$tag" => "210833370" // only for select currencies
        // }
        $address = $this->safe_string($response, 'address');
        $tag = $this->safe_string($response, 'tag');
        $this->check_address($address);
        return array(
            'currency' => $code,
            'address' => $this->check_address($address),
            'tag' => $tag,
            'info' => $response,
        );
    }

    public function fetch_deposits($code = null, $since = null, $limit = null, $params = array ()) {
        //
        //  [
        //    array(
        //      "id" => 9,
        //      "txid" => "7a91c5b321ed7f75d985c6374561e0a8de6f8ef1fa9093437e81805b0759afa8",
        //      "timestamp" => 1585236999069,
        //      "datetime" => "2020-03-26T15:36:39.069Z",
        //      "addressTo" => "bnb1j5jqey3xvs2w43x8540sd8nzykg4pyl4cvkl6x",
        //      "address" => "bnb1j5jqey3xvs2w43x8540sd8nzykg4pyl4cvkl6x",
        //      "type" => "deposit",
        //      "amount" => 0.1,
        //      "$currency" => "BNB",
        //      "status" => "FullyProcessed"
        //    ),
        $request = array();
        $this->load_markets();
        $currency = null;
        if ($code !== null) {
            $currency = $this->currency($code);
            $request['currency'] = $currency;
        }
        // No $limit or $since filter
        $response = $this->privateGetDeposits (array_merge($request, $params));
        return $this->parse_transactions($response, $currency, $since, $limit);
    }

    public function fetch_withdrawals($code = null, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $request = array();
        $currency = null;
        if ($code !== null) {
            $currency = $this->currency($code);
            $request['currency'] = $currency;
        }
        // No $limit or $since filter
        $response = $this->privateGetWithdrawals (array_merge($request, $params));
        return $this->parse_transactions($response, $currency, $since, $limit);
    }

    public function parse_transaction($transaction, $currency = null) {
        //
        //
        // -- DEPOSIT --
        // array(
        // "$id" => 9,
        // "$txid" => "7a91c5b321ed7f75d985c6374561e0a8de6f8ef1fa9093437e81805b0759afa8",
        // "$timestamp" => 1585236999069,
        // "datetime" => "2020-03-26T15:36:39.069Z",
        // "addressTo" => "bnb1j5jqey3xvs2w43x8540sd8nzykg4pyl4cvkl6x",
        // "$address" => "bnb1j5jqey3xvs2w43x8540sd8nzykg4pyl4cvkl6x",
        // "$tag" => "433519032", // only for some currencies
        // "$type" => "deposit",
        // "$amount" => 0.1,
        // "$currency" => "BNB",
        // "$status" => "FullyProcessed"
        // ),
        //
        // -- WITHDRAW --
        // {
        // "$id" => 35,
        // "$txid" => null,
        // "$timestamp" => 1588588996163,
        // "datetime" => "2020-05-04T10:43:16.163Z",
        // "addressTo" => "1Lku3CjJueSvuaexy3WQJAR9GL2q4rHV46",
        // "$address" => "1Lku3CjJueSvuaexy3WQJAR9GL2q4rHV46",
        // "$type" => "withdraw",
        // "$amount" => 1,
        // "$currency" => "BTC",
        // "$status" => "Pending2Fa",
        // "updated" => 1588588996163,
        // "$fee" => array(
        //       "$currency" => "BTC",
        //       "cost" => 0.0001
        // }
        // ),
        //
        //
        $id = $this->safe_string($transaction, 'id');
        $address = $this->safe_string($transaction, 'address');
        $tag = $this->safe_string($transaction, 'tag');
        $txid = $this->safe_value($transaction, 'txid');
        $currencyId = $this->safe_string($transaction, 'currency');
        $code = $this->safe_currency_code($currencyId);
        $timestamp = $this->parse8601($this->safe_value($transaction, 'timestamp'));
        $status = $this->safe_string($transaction, 'status');
        $type = $this->safe_string($transaction, 'type');
        $amount = $this->safe_float($transaction, 'amount');
        $fee = $this->safe_value($transaction, 'fee');
        return array(
            'info' => $transaction,
            'id' => $id,
            'txid' => $txid,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'address' => $address,
            'tag' => $tag,
            'type' => $type,
            'amount' => $amount,
            'currency' => $code,
            'status' => $status,
            'updated' => null,
            'fee' => $fee,
        );
    }

    public function withdraw($code, $amount, $address, $tag = null, $params = array ()) {
        $this->check_address($address);
        $this->load_markets();
        $currency = $this->currency($code);
        $request = array(
            'currency' => $currency['id'],
            'address' => $address,
            'amount' => floatval ($amount),
        );
        // if ($tag !== null) {
        //     $request['addressTag'] = $tag;
        // }
        $response = $this->privatePostWithdraw (array_merge($request, $params));
        return array(
            'info' => $response,
            'id' => $this->safe_string($response, 'id'),
        );
    }

    public function fetch_ticker($symbol, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $request = array(
            'symbol' => $market['id'], // i.e. MTLBTC
        );
        $response = $this->publicGetTickers (array_merge($request, $params));
        return $this->parse_ticker($response, $market);
    }

    public function fetch_tickers($symbols = null, $params = array ()) {
        $this->load_markets();
        $response = $this->publicGetTickers ($params);
        return $this->parse_tickers($response, $symbols);
    }

    public function parse_tickers($rawTickers, $symbols = null) {
        $tickers = array();
        for ($i = 0; $i < count($rawTickers); $i++) {
            $tickers[] = $this->parse_ticker($rawTickers[$i]);
        }
        return $this->filter_by_array($tickers, 'symbol', $symbols);
    }

    public function parse_ticker($ticker, $market = null) {
        // array(
        //   "$symbol" => "MTLBTC",
        //   "bidPrice" => "0.00002931",
        //   "askPrice" => "0.00002946",
        //   "lastPrice" => "0.00002946",
        //   "openPrice" => "0.00003047",
        //   "highPrice" => "0.00003149",
        //   "lowPrice" => "0.00002842",
        //   "volume" => "2085.6791445"
        // ),
        $symbol = null;
        $marketId = $this->safe_string($ticker, 'symbol');
        if (is_array($this->markets_by_id) && array_key_exists($marketId, $this->markets_by_id)) {
            $market = $this->markets_by_id[$marketId];
        }
        if ($market !== null) {
            $symbol = $market['symbol'];
        }
        $last = $this->safe_float($ticker, 'lastPrice');
        return array(
            'symbol' => $symbol,
            'timestamp' => null,
            'datetime' => null,
            'high' => $this->safe_float($ticker, 'highPrice'),
            'low' => $this->safe_float($ticker, 'lowPrice'),
            'bid' => $this->safe_float($ticker, 'bidPrice'),
            'bidVolume' => null,
            'ask' => $this->safe_float($ticker, 'askPrice'),
            'askVolume' => null,
            'vwap' => null,
            'open' => $this->safe_float($ticker, 'openPrice'),
            'close' => $last,
            'last' => $last,
            'previousClose' => null, // previous day close
            'change' => null,
            'percentage' => null,
            'average' => null,
            'baseVolume' => $this->safe_float($ticker, 'volume'),
            'quoteVolume' => null,
            'info' => $ticker,
        );
    }

    public function nonce() {
        return $this->milliseconds();
    }

    public function sign($path, $api = 'public', $method = 'GET', $params = array (), $headers = null, $body = null) {
        $fullPath = '/' . $this->version . '/' . $this->implode_params($path, $params);
        $query = $this->omit($params, $this->extract_params($path));
        if ($method === 'GET') {
            if ($query) {
                $fullPath .= '?' . $this->urlencode($query);
            }
        }
        $url = $this->urls['api'] . $fullPath;
        if ($api === 'private') {
            $this->check_required_credentials();
            if ($method !== 'GET') {
                if ($query) {
                    $body = $this->json($query);
                }
            }
            $nonce = $this->nonce();
            $apiKey = $this->apiKey;
            $user = $this->uid;
            $auth = $nonce . $apiKey . $user;
            $signature = $this->hmac($this->encode($auth), $this->encode($this->secret), 'sha256');
            $headers = array(
                'MX-API-KEY' => $apiKey,
                'MX-API-USER' => $user,
                'MX-SIGNATURE' => $signature,
                'MX-NONCE' => $nonce,
            );
        }
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }
}
